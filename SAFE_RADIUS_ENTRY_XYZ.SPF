PROC SAFE_RADIUS_ENTRY_XYZ(VAR REAL XPOS, VAR REAL YPOS, VAR REAL ZPOS, VAR REAL RZPOS, VAR REAL RYPOS, VAR REAL RXPOS, VAR REAL ROTXPOS)

;THIS MACRO TAKES IN AN INITIAL APPROACH POSITION FOR ROTX AND EXTENDS IT TO A SAFE DISTANCE FROM THE PART
;THE ENTRY POINT IS EXTRAPOLATED ALONG THE NORMAL AXIS OF THE COMMANDED POINT USING FRAMES
;ONCE THE ENTRY POINT HAS REACH THE DEFINED SAFE RADIUS FROM THE CENTER OF ROTATION, THE POINT IS UPDATED
;THE UPDATED POINT IS PASSED BACK TO THE CALLING PROGRAM BY USING THE INPUTS AS IN/OUT VARIABLES
;THE VAR COMMAND IS REQUIRED TO DEFINE VARIABLES AS IN/OUTS, USED IN THE DEFINITIONS ABOVE
;THE POINT IS OUTPUT IN THE NORMAL ROBOT BCS, SO IT CAN BE COMMANDED BEFORE THE 7 AXIS TRANSFORM IS ACTIVATED

;APPROACH MOTION DEFINITIONS
DEF REAL R_TOL = 0.5 ;MM, TOLERANCE OF CALCULATED SAFE ENTRY POSITION TO THE SAFE RADIUS
DEF REAL R_SAFE = 575.0 ;MM, ALL ROTATOR MANDRELS SHOULD BE WITHIN THIS RADIUS
DEF REAL ROTX_TILT = -20.0 ;DEG OFFSET TO TILT MOLD TOWARDS ROBOT IF REQUIRED (-20DEG GOOD DEFAULT VALUE)
DEF REAL TILT_RATIO_X = 0.015 ;DEG/MM, DEG TILT TO ADD PER MM OF START POSITION AWAY FROM ROBOT CENTER
DEF REAL TILT_RATIO_Y = 0.05 ;DEG/MM, DEG TILT TO ADD PER MM OF START POSITION BEYOND ROTX Y POSITION
DEF REAL TILT_RATIO_Z = 0.005 ;DEG/MM, DEG TILT TO ADD PER MM OF START POSITION ABOVE ROTX Z POSITION

;CALCULATION VARIABLES
DEF BOOL CALCS_DONE = FALSE
DEF INT II = 0
DEF INT II_MAX = 20
DEF REAL RAD1 = 0.0
DEF REAL RAD2 = 0.0
DEF REAL R_TEST = 0.0
DEF REAL RATIO
DEF REAL R_DIFF = 1.0 ;MM, NEEDS TO BE GREATER THAN R_TOL TO START
DEF REAL H_TEST = 10.0 ;MM, TEST HEIGHT TO TRY ABOVE THE APPROACH POINT
DEF REAL H_SAFE = 0.0 ;MM, HEIGHT REQUIRED TO REACH THE SAFE RADIUS
DEF FRAME FRAME1, FRAME2, FRAME_SAFE, FRAME_BCS
DEF REAL ROTX_XPOS
DEF REAL ROTX_YPOS
DEF REAL ROTX_ZPOS
DEF REAL TILT_X
DEF REAL TILT_Y
DEF REAL TILT_Z

;INITIALIZE VARIABLES
ROTX_XPOS = $MC_ROBX_EXT_ROT_BASE_OFFSET[0]
ROTX_YPOS = $MC_ROBX_EXT_ROT_BASE_OFFSET[1]
ROTX_ZPOS = $MC_ROBX_EXT_ROT_BASE_OFFSET[2]

;///////////////////////////////////////////////////////////////////////////////
;BEGINNING OF MACRO
;CREATE A COORDINATE SYSTEM AT THE APPROACH POINT
;FRAME1 = CTRANS(X,XPOS,Y,YPOS,Z,ZPOS):CROT(Z,RZPOS):CROT(Y,RYPOS):CROT(X,RXPOS)
FRAME1 = CTRANS(X,XPOS,Y,YPOS,Z,ZPOS):CROT(X,RZPOS):CROT(Y,RYPOS):CROT(Z,RXPOS)

;ADJUST FRAME BY THE TEST HEIGHT
FRAME2 = FRAME1:CTRANS(Z,H_TEST)

;CALCULATE THE DISTANCE FROM THE BCS ORIGIN TO EACH POINT
RAD1 = SQRT(POT(FRAME1[Y,TR])+POT(FRAME1[Z,TR])) ;POT means Power of Two, so this is the square root of the sum of squares
RAD2 = SQRT(POT(FRAME2[Y,TR])+POT(FRAME2[Z,TR]))

;LINEARLY INTERPOLATE HOW MUCH TO INCREASE THE APPROACH HEIGHT BASED ON TEST HEIGHT RESULT
;R = ((R2-R1)/H_TEST)*H + R1
;SOLVE FOR H_SAFE WHEN R = R_SAFE
;*NOTE: THIS ASSUMES THE NORMAL VECTOR ALWAYS POINTS AWAY FROM PART. IF IT DOESN'T, A CRASH IS POSSIBLE!
H_SAFE = H_TEST*((R_SAFE-RAD1)/(RAD2-RAD1));
STOPRE

;WHILE R_DIFF>R_TOL AND II<II_MAX ;ITERATE THE FOLLOWING CALCULATIONS UNTIL THE CALCULATED POSITION IS WITHIN TOLERANCE
WHILE CALCS_DONE == FALSE

    ;INCREASE HEIGHT OF FRAME1 BY H_SAFE TO FIND POSITION OF FRAME_SAFE, AND RETURN POSITIONS
    FRAME_SAFE = FRAME1:CTRANS(Z,H_SAFE)
    XPOS = FRAME_SAFE[X,TR]
    YPOS = FRAME_SAFE[Y,TR]
    ZPOS = FRAME_SAFE[Z,TR]

    ;CHECK IF CALCULATED END POSITION IS WITHIN TOLERANCE OF R_SAFE, SINCE R VS H ISN'T QUITE LINEAR
    R_TEST = SQRT(POT(YPOS)+POT(ZPOS))
    R_DIFF = ABS(R_TEST - R_SAFE)

    IF R_DIFF > R_TOL
        RATIO = R_SAFE/R_TEST
        H_SAFE = RATIO*H_SAFE
        II=II+1
    ENDIF
    STOPRE

    IF R_DIFF<=R_TOL
        CALCS_DONE = TRUE
    ENDIF
    IF II >= II_MAX
        CALCS_DONE = TRUE
    ENDIF

ENDWHILE

;ROTATE POSITIONS BACK INTO THE NORMAL ROBOT BCS
FRAME_BCS = CROT(X,-ROTXPOS):FRAME_SAFE

;CHECK IF APPROACH POINT IS PAST THE ROTATOR AXIS
; this makes sense if the arguments passed in to this macro are silly, but they are not, so lets try to skip it.
;IF FRAME_BCS[Y,TR] > 0.0
    ;IF TRUE, TILT ROTATOR TOWARDS ROBOT FOR BETTER ACCESSIBILITY
;    TILT_X = (TILT_RATIO_X*ABS(ROTX_XPOS + FRAME_BCS[X,TR])) ;APPLIES TILT WITH TILT=0 AT ROBOT CENTER
;    TILT_Y = (TILT_RATIO_Y*FRAME_BCS[Y,TR])
;    TILT_Z = (TILT_RATIO_Z*FRAME_BCS[Z,TR])
;    ROTX_TILT = -(TILT_X + TILT_Y + TILT_Z)

    ;MSG("TILT_X="<<TILT_X<<", TILT_Y="<<TILT_Y<<", TILT_Z="<<TILT_Z<<", ROTX_TILT="<<ROTX_TILT<<"")
    ;M0
    ;STOPRE

;    FRAME_BCS = CROT(X,-ROTX_TILT):FRAME_BCS
;    ROTXPOS = ROTXPOS + ROTX_TILT
;ENDIF

;UPDATE IN/OUT VARIABLES
XPOS = FRAME_BCS[X,TR]+ROTX_XPOS ;SHIFT FRAME BACK TO ROBOT BCS ORIGIN
YPOS = FRAME_BCS[Y,TR]+ROTX_YPOS ;SHIFT FRAME BACK TO ROBOT BCS ORIGIN
ZPOS = FRAME_BCS[Z,TR]+ROTX_ZPOS ;SHIFT FRAME BACK TO ROBOT BCS ORIGIN
RZPOS = FRAME_BCS[X,RT]
RYPOS = FRAME_BCS[Y,RT]
RXPOS = FRAME_BCS[Z,RT]

;CALCULATIONS COMPLETE

;TEST BY UNCOMMENTING THE FOLLOWING LINES:
;MSG("COMPLETE. XPOS="<<XPOS<<", YPOS="<<YPOS<<", ZPOS="<<ZPOS<<",R_TEST="<<R_TEST<<",R_DIFF="<<R_DIFF<<", II="<<II<<"")
;M0
;STOPRE
;MSG("ROTATIONS: RZ="<<RZPOS<<", RY="<<RYPOS<<", RX="<<RXPOS<<"")
;M0
;STOPRE

RET
