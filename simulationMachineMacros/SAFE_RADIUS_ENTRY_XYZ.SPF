PROC SAFE_RADIUS_ENTRY_XYZ(VAR REAL XPOS, VAR REAL YPOS, VAR REAL ZPOS, VAR REAL RXPOS, VAR REAL RYPOS, VAR REAL RZPOS, VAR REAL ROTXPOS)

    ; Frame declarations
    DEF FRAME FRAME1, FRAME_SAFE

    ; Intermediate math
    DEF REAL KX
    DEF REAL KY
    DEF REAL KZ
    DEF REAL KY_TEMP
    DEF REAL V_LEN
    DEF REAL RXT, RYT, RZT
    
    ; Constants
    DEF REAL R_SAFE
    R_SAFE = 575.0

    ; Build approach frame from input pose
    FRAME1 = CTRANS(X, XPOS, Y, YPOS, Z, ZPOS):CROT(X, RXPOS):CROT(Y, RYPOS):CROT(Z, RZPOS)
    
    ; Rotate into unrotated mandrel coordinate system
    FRAME1 = CROT(X, -ROTXPOS):FRAME1

    KX = 0.0
    KY = 0.0
    KZ = 0.0


    ; Calculate the radial vector components based on the input angles
    KX = SIN(RYPOS)
    KY = -SIN(RXPOS) * COS(RYPOS)
    KZ =  COS(RXPOS) * COS(RYPOS)      

    ; Rotate the radial vector into the unrotated mandrel coordinate system
    KY_TEMP = COS(-ROTXPOS) * KY - SIN(-ROTXPOS) * KZ
    KZ = SIN(-ROTXPOS) * KY + COS(-ROTXPOS) * KZ
    KY = KY_TEMP

    RXT = -ATAN2(KY, KZ)
    RYT = ASIN(KX)
    RZT = RZPOS

    KX = KX
    ; Normalize the radial vector
    V_LEN = SQRT(POT(KY) + POT(KZ))
    KY = KY / V_LEN
    KZ = KZ / V_LEN

    ; Scale by safe offset
    KX = KX * R_SAFE
    KY = KY * R_SAFE
    KZ = KZ * R_SAFE
    
    ; Output final position
    XPOS  = FRAME1[X,TR] + KX
    YPOS  = KY
    ZPOS  = KZ

    FRAME_SAFE = CROT(X, ROTXPOS):CTRANS(X, XPOS, Y, YPOS, Z, ZPOS)

    XPOS = FRAME_SAFE[X,TR]
    YPOS = FRAME_SAFE[Y,TR]
    ZPOS = FRAME_SAFE[Z,TR]

    RXPOS = RXT + ROTXPOS
    RYPOS = RYT
    RZPOS = RZT

RET
